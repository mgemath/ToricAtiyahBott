var documenterSearchIndex = {"docs":
[{"location":"#ToricAtiyahBott.jl","page":"ToricAtiyahBott.jl","title":"ToricAtiyahBott.jl","text":"","category":"section"},{"location":"","page":"ToricAtiyahBott.jl","title":"ToricAtiyahBott.jl","text":"","category":"page"},{"location":"","page":"ToricAtiyahBott.jl","title":"ToricAtiyahBott.jl","text":"ToricAtiyahBott","category":"page"},{"location":"#ToricAtiyahBott","page":"ToricAtiyahBott.jl","title":"ToricAtiyahBott","text":"ToricAtiyahBott is a module containing an implementation of the Kontsevich-Atiyah-Bott residue formula for toric varieties in the Julia language. The theory and the algorithm behind the package is described in the paper  \"Computations of Gromov-Witten invariants of toric varieties\" by GiosuÃ¨ Muratore.\n\n\n\n\n\n","category":"module"},{"location":"","page":"ToricAtiyahBott.jl","title":"ToricAtiyahBott.jl","text":"In order to install the package, type:","category":"page"},{"location":"","page":"ToricAtiyahBott.jl","title":"ToricAtiyahBott.jl","text":"julia> using Pkg\njulia> Pkg.add(\"ToricAtiyahBott\")","category":"page"},{"location":"","page":"ToricAtiyahBott.jl","title":"ToricAtiyahBott.jl","text":"After the installation, simply type:","category":"page"},{"location":"","page":"ToricAtiyahBott.jl","title":"ToricAtiyahBott.jl","text":"julia> using ToricAtiyahBott","category":"page"},{"location":"","page":"ToricAtiyahBott.jl","title":"ToricAtiyahBott.jl","text":"every time you want to use the program. This package requires Oscar, so make sure that you can use Oscar before installing this package. See https://www.oscar-system.org/install/.","category":"page"},{"location":"#The-function-IntegrateAB","page":"ToricAtiyahBott.jl","title":"The function IntegrateAB","text":"","category":"section"},{"location":"","page":"ToricAtiyahBott.jl","title":"ToricAtiyahBott.jl","text":"This is the main function of the package.","category":"page"},{"location":"","page":"ToricAtiyahBott.jl","title":"ToricAtiyahBott.jl","text":"IntegrateAB","category":"page"},{"location":"#ToricAtiyahBott.IntegrateAB","page":"ToricAtiyahBott.jl","title":"ToricAtiyahBott.IntegrateAB","text":"IntegrateAB(v, beta, m, P; do_check, show_bar)\n\nApply the Atiyah-Bott residue formula to compute the integral of the equivariant class P in the moduli space of rational marked stable maps to the toric variety v of class beta with m marks.\n\nArguments\n\nv::NormalToricVariety: the toric variety.\nbeta::CohomologyClass: the class of the stable maps, it must be the effective class of a curve.\nm::Int64: the number of marks.\nP: the equivariant class.\ndo_check::Bool: if true, checks if P is a well defined zero cycle, and stops the computation if this is not true. If false, the computation may have an unexpected behaviour. By default is true.\nshow_bar::Bool: hide the progress bar if and only if this condition is false. By default is true.\n\nIn order to use this function, one must define v, beta and P using Oscar:\n\njulia> v = del_pezzo_surface(1); # this is the blow-up of the projective plane at a point\n\njulia> beta = cohomology_class(toric_divisor(v, [0,0,1,0])); # class of pull back of a line of P2\n\njulia> P = ev(1, a_point(v))*ev(2, a_point(v)); # pull back of a point through the first and second evaluations maps\n\njulia> IntegrateAB(v, beta, 2, P, show_bar=false); # show_bar can be also true\nResult: 1\n\nThe function returns an array of the same dimension of P (non-vectorized classes are assumed as 1-dimensional arrays). The Julia notation for accessing to array is name_of_array[i] where i is an index starting from 1.\n\nMore examples are available in the support of the equivariant classes. It is enough to type ? and then the name of the class. Currently, the supported classes are:\n\nev(j, cc) (Euler class of mathrmev_j^*(cc) where cc is either a cohomology class or a line bundle)\nPsi(a)    (cycle of psi-classes)\npush_ev(l)(push-forward under the forget map of mathrmev_j^*(l))\nR1_ev(l)  (first derived functor of the pull-back of mathrmev_j^*(l))\nJet(p, l) (Euler class of the jet bundle J^p of the line bundle l)\n\nTo add more classes, please contact the authors.\n\n\n\n\n\n","category":"function"},{"location":"#Equivariant-Classes","page":"ToricAtiyahBott.jl","title":"Equivariant Classes","text":"","category":"section"},{"location":"","page":"ToricAtiyahBott.jl","title":"ToricAtiyahBott.jl","text":"Here we list all equivariant classes currently supported by the package.","category":"page"},{"location":"","page":"ToricAtiyahBott.jl","title":"ToricAtiyahBott.jl","text":"ev\nPsi\npush_ev\nR1_ev\nJet\npush_omega","category":"page"},{"location":"#ToricAtiyahBott.ev","page":"ToricAtiyahBott.jl","title":"ToricAtiyahBott.ev","text":"ev(j, cc)\nev(j, l)\n\nEquivariant class of the pull-back of the cohomology class cc (or the toric line bundle l) with respect to the j-th evaluation map.\n\nArguments\n\nj::Int64: the evaluation map.\ncc::CohomologyClass: the cohomology class.\nl::ToricLineBundle: the line bundle.\n\nExample\n\nThe following Gromov-Witten invariants\n\nbeginaligned\nint_overlineM_02(mathbbP^11)mathrmev_1^*mathcalO_mathbbP^1(1)cdotmathrmev_2^*mathcalO_mathbbP^1(1) = 1 \nint_overlineM_02(mathbbP^21)(mathrmev_1^*mathcalO_mathbbP^2(1)cdotmathrmev_2^*mathcalO_mathbbP^2(1))^2 = 1 \nendaligned\n\ncan be computed as\n\njulia> v = projective_space(NormalToricVariety, 1);  # 1-dimensional projective space\n\njulia> p = a_point(v); # the cohomology class of a point. Note that p^0 gives the class of the entire variety\n\njulia> P = ev(1, p)*ev(2, p);\n\njulia> IntegrateAB(v, p^0, 2, P, show_bar=false); # show_bar can be also true\nResult: 1\n\njulia> v = projective_space(NormalToricVariety, 2);  # 2-dimensional projective space\n\njulia> l = toric_line_bundle(v, [1]);\n\njulia> P = (ev(1, l)*ev(2, l))^2;\n\njulia> line = cohomology_class(toric_divisor(v, [1,0,0]));\n\njulia> IntegrateAB(v, line, 2, P, show_bar=false); # show_bar can be also true\nResult: 1\n\nwarning: Attention!\nThe program will stop if j is not between 1 and the number of marks.\n\nLet us give some more examples. Let v = mathbbP(mathcalO_mathbbP^3oplusmathcalO_mathbbP^3(5)).\n\njulia> P3 = projective_space(NormalToricVariety, 3);\njulia> v = proj(toric_line_bundle(P3, [0]),toric_line_bundle(P3, [5]));\n\nUsing moment_graph we have a quick access to the moment graph of v.\n\njulia> mg = moment_graph(v);\n\nConsider the following curve class.\n\njulia> beta = mg[1,2];\n\nIf mathrmp is the class of a point of v, in order to compute the following invariant\n\nbeginaligned\nint_overlineM_01(v beta) mathrmev_1^*(mathrmp) = 1 \nendaligned\n\nwe use the code:\n\njulia> P = ev(1, a_point(v));\njulia> IntegrateAB(v, beta, 1, P);\n\nIn order to speed up the computation, many equivariant classes of the same moduli space can be vectorized. For example the following two invariants are in the same moduli space.\n\nbeginaligned\nint_overlineM_02(mathbbP^2 1) mathrmev_1^*(mathrmp)cdotmathrmev_2^*(mathrmp) = 1 \nint_overlineM_02(mathbbP^2 1) mathrmev_1^*(mathrmp)cdotpsi_1^1cdotpsi_2^1 = -1 \nendaligned\n\nThe best way to compute them is by defining an array P=[P1,P2] and compute them together.\n\njulia> v = projective_space(NormalToricVariety, 2);\n\njulia> p = a_point(v);\n\njulia> P1 = ev(1, p)*ev(2, p);\n\njulia> P2 = ev(1, p)*Psi([1,1]);\n\njulia> P = [P1,P2];\n\njulia> line = cohomology_class(toric_divisor(v, [1,0,0]));\n\njulia> IntegrateAB(v, line, 2, P, show_bar=false);\nResult number 1: 1\nResult number 2: -1\n\n\n\n\n\n","category":"function"},{"location":"#ToricAtiyahBott.Psi","page":"ToricAtiyahBott.jl","title":"ToricAtiyahBott.Psi","text":"Psi(a)\n\nEquivariant class of the cycle of psi-classes.\n\nArguments\n\na::Vector{Int64}: the vector of the exponents of the psi classes. It is ordered, meaning that the first element is the exponent of psi_1, the second is the exponent of psi_2, and so on. Alternatively, a can be a number. In this case it is equivalent to [1,0,0,...,0].\n\nnote: Note\nThe size of a must be at most m. If it is smaller, missing exponents will be considered as zeros. If a is a number, it will be considered as the exponent of psi_1.\n\nwarning: Attention!\nThe program will stop if we have one of the following conditions:the size of a is bigger than m,\na contains a negative number.\n\nExample\n\nThe following Gromov-Witten invariants\n\nbeginaligned\nint_overlineM_01(mathbbP^22)mathrmev_1^*mathcalO_mathbbP^2(1)^2cdotpsi_1^4 = frac18 \nint_overlineM_02(mathbbP^21)psi_1^2psi_2^2 = 6 \nint_overlineM_01(mathbbP^32)mathrmev_1^*mathcalO_mathbbP^2(1)cdot(psi_1^7cdotmathrmev_1^*mathcalO_mathbbP^2(1)+psi_1^6cdotmathrmev_1^*mathcalO_mathbbP^2(1)^2) = -frac516 \nendaligned\n\ncan be computed as\n\njulia> v = projective_space(NormalToricVariety, 2);  # 2-dimensional projective space\n\njulia> line = cohomology_class(toric_divisor(v, [1,0,0])); # the cohomology class of a line\n\njulia> P = ev(1, line)^2*Psi(4);\n\njulia> IntegrateAB(v, 2*line, 1, P, show_bar=false);\nResult: 1//8\n\njulia> Q = Psi([2,2]);\n\njulia> IntegrateAB(v, line, 2, Q, show_bar=false);\nResult: 6\n\njulia> v = projective_space(NormalToricVariety, 3);  # 3-dimensional projective space\n\njulia> plane = cohomology_class(toric_line_bundle(v, [1])); # cohomology class of a plane\n\njulia> P = ev(1, plane)*(Psi(7)*ev(1, plane)+Psi(6)*ev(1, plane)^2);\n\njulia> IntegrateAB(v, 2*plane^2, 1, P, show_bar=false);\nResult: -5//16\n\nwarning: Psi is singleton!\nPsi cannot be multiplied by itself.julia> v = projective_space(NormalToricVariety, 2);  # 2-dimensional projective space\njulia> line = cohomology_class(toric_divisor(v, [1,0,0])); # the cohomology class of a line\njulia> P = ev(1, line)^2*Psi(1)^4;                  #this is **wrong**\njulia> IntegrateAB(v, 2*line, 1, P);\nWarning: more instances of Psi has been found. Type:\njulia> ?Psi\nfor support.\njulia> P = ev(1, line)^2*Psi(3)*Psi(1);            #this is **wrong**\njulia> IntegrateAB(v, 2*line, 1, P);\nWarning: more instances of Psi has been found. Type:\njulia> ?Psi\nfor support.\njulia> P = ev(1, line)^2*Psi(4);\njulia> IntegrateAB(v, 2*line, 1, P);\nResult: 1//8\n\n\n\n\n\n","category":"function"},{"location":"#ToricAtiyahBott.push_ev","page":"ToricAtiyahBott.jl","title":"ToricAtiyahBott.push_ev","text":"push_ev(l)\n\nEquivariant class of the push-forward under the forget map of the pull-back of the  toric line bundle l.\n\nArguments\n\nl::ToricLineBundle: the line bundle.\n\nExample\n\nThe following Gromov-Witten invariants\n\nbeginaligned\nint_overlineM_00(mathbbP^41)mathrmc_top(delta_*(mathrmev^*mathcalO_mathbbP^4(5))) = 2875 \nint_overlineM_01(mathbbP^41)mathrmc_top(delta_*(mathrmev^*mathcalO_mathbbP^4(5)))cdotpsi_1^1 = -5750\nendaligned\n\ncan be computed as\n\njulia> v = projective_space(NormalToricVariety, 4);\n\njulia> line = cohomology_class(toric_line_bundle(v, [1]))^3;\n\njulia> P = push_ev(toric_line_bundle(v, [5]));\n\njulia> IntegrateAB(v, line, 0, P, show_bar=false);\nResult: 2875\n\njulia> P = push_ev(toric_line_bundle(v, [5]))*Psi(1);\n\njulia> IntegrateAB(v, line, 1, P, show_bar=false);\nResult: -5750\n\n\n\n\n\n","category":"function"},{"location":"#ToricAtiyahBott.R1_ev","page":"ToricAtiyahBott.jl","title":"ToricAtiyahBott.R1_ev","text":"R1_ev(l)\n\nThe equivariant class of the first derived functor of the pull-back of the toric line bundle l.\n\nArguments\n\nl::ToricLineBundle: the line bundle.\n\nExample\n\nbeginaligned\nint_overlineM_00(mathbbP^1d)mathrmc_top(R^1delta_*(mathrmev^*mathcalO_mathbbP^3(-1)))^2 = frac1d^3 \nendaligned\n\ncan be computed as\n\njulia> P1 = projective_space(NormalToricVariety, 1);\n\njulia> beta = moment_graph(P1)[1,2];\n(1,2) -> 1\n\njulia> P = R1_ev(toric_line_bundle(P1, [-1]))^2;\n\njulia> IntegrateAB(P1, beta, 0, P, show_bar=false);\nResult: 1\n\n\n\n\n\n","category":"function"},{"location":"#ToricAtiyahBott.Jet","page":"ToricAtiyahBott.jl","title":"ToricAtiyahBott.Jet","text":"Jet(p, l)\n\nEquivariant class of the jet bundle J^p of the pull back of the toric line bundle l with respect to the first psi-class.\n\nArguments\n\np::Int64: the exponent of the Jet bundle. In particular, it is a bundle of rank p+1.\nl::Int64: the toric line bundle that is pulled back.\n\nnote: Note\nIn order to define this bundle, the number of marks must be at least 1. You cannot multiply this bundle by the class Psi(a).\n\nExample\n\nbeginaligned\nint_overlineM_01(mathbbP^3d)fracmathrmev_1^*mathcalO_mathbbP^3(1)^2kcdotmathrmc_top(J^4d-2(mathrmev_1^*mathcalO_mathbbP^3(k))) = frac(4d-2)(d)^4 \nint_overlineM_01(mathbbP^21)mathrmc_top(J^3(mathrmev_1^*mathcalO_mathbbP^2(3))) = 9 \nendaligned\n\ncan be computed as\n\njulia> d=1;k=1; #for other values of d, change this line\n\njulia> v = projective_space(NormalToricVariety, 3);\n\njulia> line = cohomology_class(toric_divisor(v, [1,0,0,0]))^2;\n\njulia> beta = d*line;\n\njulia> l = toric_line_bundle(v, [k]);\n\njulia> P = ev(1,line)//k*Jet(4*d-2,l);\n\njulia> IntegrateAB(v, beta, 1, P, show_bar=false);   #The value of this integral does not depend on k, only on d\nResult: 2\n\njulia> v = projective_space(NormalToricVariety, 2);\n\njulia> l = toric_line_bundle(v, [1]);\n\njulia> line = cohomology_class(l);\n\njulia> IntegrateAB(v, line, 1, Jet(2, l^3), show_bar=false); # flexes of a cubic curve\nResult: 9\n\n\n\n\n\n","category":"function"},{"location":"#ToricAtiyahBott.push_omega","page":"ToricAtiyahBott.jl","title":"ToricAtiyahBott.push_omega","text":"push_omega(l)\n\nEquivariant class of the push-forward under the forgetful map of ev^*l tensored the cotangent bundle of the forgetful map.\n\nArguments\n\nl::ToricLineBundle: the line bundle.\n\nExample\n\nThe following Gromov-Witten invariants\n\nbeginaligned\nint_overlineM_02(mathbbP^31)mathrmev_1^*mathcalO_mathbbP^3(1)^2cdotmathrmev_2^*mathcalO_mathbbP^3(1)^3cdotmathrmc_top(delta_*(omega_deltaotimesmathrmev^*mathcalO_mathbbP^3(2))) = 1 \nendaligned\n\ncan be computed as\n\njulia> v = projective_space(NormalToricVariety, 3);\n\njulia> line = cohomology_class(toric_line_bundle(v, [1]))^2;\n\njulia> P = push_omega(toric_line_bundle(v, [2]))*ev(1, line)*ev(2, a_point(v));\n\njulia> IntegrateAB(v, line, 2, P, show_bar=false);\nResult: 1\n\n\n\n\n\n","category":"function"},{"location":"#Other-Functions","page":"ToricAtiyahBott.jl","title":"Other Functions","text":"","category":"section"},{"location":"","page":"ToricAtiyahBott.jl","title":"ToricAtiyahBott.jl","text":"vir_dim_M\ncodimension\nis_zero_cycle\na_point\nproj\nmoment_graph","category":"page"},{"location":"#ToricAtiyahBott.vir_dim_M","page":"ToricAtiyahBott.jl","title":"ToricAtiyahBott.vir_dim_M","text":"vir_dim_M(v, beta, m)\n\nThe virtual dimension of the moduli space of stable rational map to the toric variety v, of class beta with m marks.\n\nArguments\n\nv::NormalToricVariety: the toric variety.\nbeta::CohomologyClass: the class of the stable maps.\nm::Int64: the number of marks.\n\nExample\n\njulia> v = projective_space(NormalToricVariety, 2);\n\njulia> beta = cohomology_class(toric_divisor(v, [1,0,0]));\n\njulia> vir_dim_M(v,beta,0)\n2\n\n\n\n\n\n","category":"function"},{"location":"#ToricAtiyahBott.codimension","page":"ToricAtiyahBott.jl","title":"ToricAtiyahBott.codimension","text":"codimension(v, beta, m, P)\n\nThe codimension of the equivariant class P.\n\nArguments\n\nv::NormalToricVariety: the toric variety.\nbeta::CohomologyClass: the class of the stable maps.\nm::Int64: the number of marks. If omitted, it is assumed as m=0.\nP: the equivariant class.\n\n\n\n\n\n","category":"function"},{"location":"#ToricAtiyahBott.is_zero_cycle","page":"ToricAtiyahBott.jl","title":"ToricAtiyahBott.is_zero_cycle","text":"is_zero_cycle(v, beta, m, P)\n\nReturn true if the equivariant class P is a 0-cycle in the moduli space, false otherwise.\n\nArguments\n\nv::NormalToricVariety: the toric variety.\nbeta::CohomologyClass: the class of the stable maps.\nm::Int64: the number of marks.\nP: the equivariant class.\n\n\n\n\n\n","category":"function"},{"location":"#ToricAtiyahBott.a_point","page":"ToricAtiyahBott.jl","title":"ToricAtiyahBott.a_point","text":"a_point(v)\n\nThe cohomology of a point of v.\n\nArguments\n\nv::NormalToricVariety: the toric variety.\n\n\n\n\n\n","category":"function"},{"location":"#ToricAtiyahBott.proj","page":"ToricAtiyahBott.jl","title":"ToricAtiyahBott.proj","text":"proj(E...)\n\nProjectivization of the direct sum of the line bundles (or toric divisors) in E. \n\nArguments\n\nE: a sequence of line bundles (or toric divisors) on a toric variety.\n\nnote: Note\nThe line bundles must be on the same toric variety.\n\nExample\n\nLet us construct v = mathbbP(mathcalO_mathbbP^1timesmathbbP^1(10)oplusmathcalO_mathbbP^1timesmathbbP^1(01)).\n\njulia> P1 = projective_space(NormalToricVariety, 1);\njulia> D0 = toric_divisor(P1, [0,0]);\njulia> P1xP1 = proj(D0, D0);\njulia> O10 = toric_line_bundle(P1xP1, [1,0]);\njulia> O01 = toric_line_bundle(P1xP1, [0,1]);\njulia> v = proj(O10, O01);\n\n\n\n\n\n","category":"function"},{"location":"#ToricAtiyahBott.moment_graph","page":"ToricAtiyahBott.jl","title":"ToricAtiyahBott.moment_graph","text":"moment_graph(v; show_graph)\n\nThe moment graph of the toric variety v. It prints all pairs (ij), together with the cohomology class of the invariant curve passing through the points corresponding to the maximal cones i and j. The cohomology class is expressed in the coordinates of the Chow ring. \n\nArguments\n\nv::NormalToricVariety: the toric variety.\n\nExample\n\njulia> P2 = projective_space(NormalToricVariety, 2);\n\njulia> mg = moment_graph(P2);\n(1,2) -> x3\n(1,3) -> x3\n(2,3) -> x3\n\njulia> C = mg[1,2];\n\nIf show_graph is omitted or false, the output is omitted.\n\njulia> P1 = projective_space(NormalToricVariety, 1);\n\njulia> mg = moment_graph(P1, show_graph=false);\n\n\n\n\n\n","category":"function"},{"location":"#Index","page":"ToricAtiyahBott.jl","title":"Index","text":"","category":"section"},{"location":"","page":"ToricAtiyahBott.jl","title":"ToricAtiyahBott.jl","text":"","category":"page"}]
}
