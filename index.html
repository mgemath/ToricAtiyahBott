<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>ToricAtiyahBott.jl · ToricAtiyahBott</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>ToricAtiyahBott</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>ToricAtiyahBott.jl</a><ul class="internal"><li><a class="tocitem" href="#The-function-IntegrateAB"><span>The function IntegrateAB</span></a></li><li><a class="tocitem" href="#Equivariant-Classes"><span>Equivariant Classes</span></a></li><li><a class="tocitem" href="#Other-Functions"><span>Other Functions</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>ToricAtiyahBott.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>ToricAtiyahBott.jl</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/mgemath/ToricAtiyahBott.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="ToricAtiyahBott.jl"><a class="docs-heading-anchor" href="#ToricAtiyahBott.jl">ToricAtiyahBott.jl</a><a id="ToricAtiyahBott.jl-1"></a><a class="docs-heading-anchor-permalink" href="#ToricAtiyahBott.jl" title="Permalink"></a></h1><ul><li><a href="#ToricAtiyahBott.jl">ToricAtiyahBott.jl</a></li><li class="no-marker"><ul><li><a href="#The-function-IntegrateAB">The function IntegrateAB</a></li><li><a href="#Equivariant-Classes">Equivariant Classes</a></li><li><a href="#Other-Functions">Other Functions</a></li><li><a href="#Index">Index</a></li></ul></li></ul><article class="docstring"><header><a class="docstring-binding" id="ToricAtiyahBott" href="#ToricAtiyahBott"><code>ToricAtiyahBott</code></a> — <span class="docstring-category">Module</span></header><section><div><p><strong>ToricAtiyahBott</strong> is a module containing an implementation of the Kontsevich-Atiyah-Bott residue formula for toric varieties in the Julia language. The theory and the algorithm behind the package is described in the paper  &quot;Computations of Gromov-Witten invariants of toric varieties&quot; by Giosuè Muratore.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mgemath/ToricAtiyahBott.jl/blob/9a00c7a10e8c198e10e7843ffe261af037c9c8c1/src/ToricAtiyahBott.jl#L1-L6">source</a></section></article><p>In order to install the package, type:</p><pre><code class="language-julia-repl hljs">julia&gt; using Pkg
julia&gt; Pkg.add(&quot;ToricAtiyahBott&quot;)</code></pre><p>After the installation, simply type:</p><pre><code class="language-julia-repl hljs">julia&gt; using ToricAtiyahBott</code></pre><p>every time you want to use the program. This package requires Oscar, so make sure that you can use Oscar before installing this package. See https://www.oscar-system.org/install/.</p><h2 id="The-function-IntegrateAB"><a class="docs-heading-anchor" href="#The-function-IntegrateAB">The function IntegrateAB</a><a id="The-function-IntegrateAB-1"></a><a class="docs-heading-anchor-permalink" href="#The-function-IntegrateAB" title="Permalink"></a></h2><p>This is the main function of the package.</p><article class="docstring"><header><a class="docstring-binding" id="ToricAtiyahBott.IntegrateAB" href="#ToricAtiyahBott.IntegrateAB"><code>ToricAtiyahBott.IntegrateAB</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">IntegrateAB(v, beta, m, P; do_check, show_bar)</code></pre><p>Apply the Atiyah-Bott residue formula to compute the integral of the equivariant class <code>P</code> in the moduli space of rational marked stable maps to the toric variety <code>v</code> of class <code>beta</code> with <code>m</code> marks.</p><p><strong>Arguments</strong></p><ul><li><code>v::NormalToricVariety</code>: the toric variety.</li><li><code>beta::CohomologyClass</code>: the class of the stable maps, it must be the effective class of a curve.</li><li><code>m::Int64</code>: the number of marks.</li><li><code>P</code>: the equivariant class.</li><li><code>do_check::Bool</code>: if <code>true</code>, checks if <code>P</code> is a well defined zero cycle, and stops the computation if this is not true. If <code>false</code>, the computation may have an unexpected behaviour. By default is <code>true</code>.</li><li><code>show_bar::Bool</code>: hide the progress bar if and only if this condition is <code>false</code>. By default is <code>true</code>.</li></ul><p>In order to use this function, one must define <code>v</code>, <code>beta</code> and <code>P</code> using Oscar:</p><pre><code class="language-julia-repl hljs">julia&gt; v = del_pezzo_surface(1); # this is the blow-up of the projective plane at a point

julia&gt; beta = cohomology_class(toric_divisor(v, [0,0,1,0])); # class of pull back of a line of P2

julia&gt; P = ev(1, a_point(v))*ev(2, a_point(v)); # pull back of a point through the first and second evaluations maps

julia&gt; IntegrateAB(v, beta, 2, P, show_bar=false); # show_bar can be also true
Result: 1</code></pre><p>The function returns an array of the same dimension of <code>P</code> (non-vectorized classes are assumed as 1-dimensional arrays). The Julia notation for accessing to array is <code>name_of_array[i]</code> where <code>i</code> is an index starting from 1.</p><p>More examples are available in the support of the equivariant classes. It is enough to type <code>?</code> and then the name of the class. Currently, the supported classes are:</p><ul><li><code>ev(j, cc)</code> (Euler class of <span>$\mathrm{ev}_j^*(cc)$</span> where <span>$cc$</span> is either a cohomology class or a line bundle)</li><li><code>Psi(a)</code>    (cycle of <span>$\psi$</span>-classes)</li><li><code>push_ev(l)</code>(push-forward under the forget map of <span>$\mathrm{ev}_j^*(l)$</span>)</li><li><code>R1_ev(l)</code>  (first derived functor of the pull-back of <span>$\mathrm{ev}_j^*(l)$</span>)</li><li><code>Jet(p, l)</code> (Euler class of the jet bundle <span>$J^p$</span> of the line bundle <span>$l$</span>)</li></ul><p>To add more classes, please contact the authors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mgemath/ToricAtiyahBott.jl/blob/9a00c7a10e8c198e10e7843ffe261af037c9c8c1/src/Main.jl#L7-L41">source</a></section></article><h2 id="Equivariant-Classes"><a class="docs-heading-anchor" href="#Equivariant-Classes">Equivariant Classes</a><a id="Equivariant-Classes-1"></a><a class="docs-heading-anchor-permalink" href="#Equivariant-Classes" title="Permalink"></a></h2><p>Here we list all equivariant classes currently supported by the package.</p><article class="docstring"><header><a class="docstring-binding" id="ToricAtiyahBott.ev" href="#ToricAtiyahBott.ev"><code>ToricAtiyahBott.ev</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ev(j, cc)
ev(j, l)</code></pre><p>Equivariant class of the pull-back of the cohomology class <span>$cc$</span> (or the toric line bundle <span>$l$</span>) with respect to the j-th evaluation map.</p><p><strong>Arguments</strong></p><ul><li><code>j::Int64</code>: the evaluation map.</li><li><code>cc::CohomologyClass</code>: the cohomology class.</li><li><code>l::ToricLineBundle</code>: the line bundle.</li></ul><p><strong>Example</strong></p><p>The following Gromov-Witten invariants</p><p class="math-container">\[\begin{aligned}
\int_{\overline{M}_{0,2}(\mathbb{P}^{1},1)}\mathrm{ev}_{1}^{*}\mathcal{O}_{\mathbb{P}^{1}}(1)\cdot\mathrm{ev}_{2}^{*}\mathcal{O}_{\mathbb{P}^{1}}(1) &amp;= 1 \\
\int_{\overline{M}_{0,2}(\mathbb{P}^{2},1)}(\mathrm{ev}_{1}^{*}\mathcal{O}_{\mathbb{P}^{2}}(1)\cdot\mathrm{ev}_{2}^{*}\mathcal{O}_{\mathbb{P}^{2}}(1))^2 &amp;= 1 \\
\end{aligned}\]</p><p>can be computed as</p><pre><code class="language-julia-repl hljs">julia&gt; v = projective_space(NormalToricVariety, 1);  # 1-dimensional projective space

julia&gt; p = a_point(v); # the cohomology class of a point. Note that p^0 gives the class of the entire variety

julia&gt; P = ev(1, p)*ev(2, p);

julia&gt; IntegrateAB(v, p^0, 2, P, show_bar=false); # show_bar can be also true
Result: 1

julia&gt; v = projective_space(NormalToricVariety, 2);  # 2-dimensional projective space

julia&gt; l = toric_line_bundle(v, [1]);

julia&gt; P = (ev(1, l)*ev(2, l))^2;

julia&gt; line = cohomology_class(toric_divisor(v, [1,0,0]));

julia&gt; IntegrateAB(v, line, 2, P, show_bar=false); # show_bar can be also true
Result: 1</code></pre><div class="admonition is-warning"><header class="admonition-header">Attention!</header><div class="admonition-body"><p>The program will stop if <code>j</code> is not between 1 and the number of marks.</p></div></div><p>Let us give some more examples. Let <span>$v = \mathbb{P}(\mathcal{O}_{\mathbb{P}^3}\oplus\mathcal{O}_{\mathbb{P}^3}(5))$</span>.</p><pre><code class="language-julia-repl hljs">julia&gt; P3 = projective_space(NormalToricVariety, 3);
julia&gt; v = proj(toric_line_bundle(P3, [0]),toric_line_bundle(P3, [5]));</code></pre><p>Using <a href="#ToricAtiyahBott.moment_graph"><code>moment_graph</code></a> we have a quick access to the moment graph of <span>$v$</span>.</p><pre><code class="language-julia-repl hljs">julia&gt; mg = moment_graph(v);</code></pre><p>Consider the following curve class.</p><pre><code class="language-julia-repl hljs">julia&gt; beta = mg[1,2];</code></pre><p>If <span>$\mathrm{p}$</span> is the class of a point of <span>$v$</span>, in order to compute the following invariant</p><p class="math-container">\[\begin{aligned}
\int_{\overline{M}_{0,1}(v, \beta)} \mathrm{ev}_{1}^{*}(\mathrm{p}) &amp;= 1 \\
\end{aligned}\]</p><p>we use the code:</p><pre><code class="language-julia-repl hljs">julia&gt; P = ev(1, a_point(v));
julia&gt; IntegrateAB(v, beta, 1, P);</code></pre><p>In order to speed up the computation, many equivariant classes of the same moduli space can be vectorized. For example the following two invariants are in the same moduli space.</p><p class="math-container">\[\begin{aligned}
\int_{\overline{M}_{0,2}(\mathbb{P}^2, 1)} \mathrm{ev}_{1}^{*}(\mathrm{p})\cdot\mathrm{ev}_{2}^{*}(\mathrm{p}) &amp;= 1 \\
\int_{\overline{M}_{0,2}(\mathbb{P}^2, 1)} \mathrm{ev}_{1}^{*}(\mathrm{p})\cdot\psi_{1}^{1}\cdot\psi_{2}^{1} &amp;= -1. \
\end{aligned}\]</p><p>The best way to compute them is by defining an array <code>P=[P1,P2]</code> and compute them together.</p><pre><code class="language-julia-repl hljs">julia&gt; v = projective_space(NormalToricVariety, 2);

julia&gt; p = a_point(v);

julia&gt; P1 = ev(1, p)*ev(2, p);

julia&gt; P2 = ev(1, p)*Psi([1,1]);

julia&gt; P = [P1,P2];

julia&gt; line = cohomology_class(toric_divisor(v, [1,0,0]));

julia&gt; IntegrateAB(v, line, 2, P, show_bar=false);
Result number 1: 1
Result number 2: -1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mgemath/ToricAtiyahBott.jl/blob/9a00c7a10e8c198e10e7843ffe261af037c9c8c1/src/ev_class.jl#L4-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ToricAtiyahBott.Psi" href="#ToricAtiyahBott.Psi"><code>ToricAtiyahBott.Psi</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Psi(a)</code></pre><p>Equivariant class of the cycle of <span>$\psi$</span>-classes.</p><p><strong>Arguments</strong></p><ul><li><code>a</code>: the list of exponents of the <span>$\psi$</span> classes. It is ordered, meaning that the first element is the exponent of <span>$\psi_1$</span>, the second is the exponent of <span>$\psi_2$</span>, and so on. Alternatively, <code>a</code> can be a number. In this case it is equivalent to [1,0,0,...,0].</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The size of <code>a</code> must be at most <code>m</code>. If it is smaller, missing exponents will be considered as zeros. If <code>a</code> is a number, it will be considered as the exponent of <span>$\psi_1$</span>.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Attention!</header><div class="admonition-body"><p>The program will stop if we have one of the following conditions:</p><ul><li>the size of <code>a</code> is bigger than <code>m</code>,</li><li><code>a</code> contains a negative number.</li></ul></div></div><p><strong>Example</strong></p><p>The following Gromov-Witten invariants</p><p class="math-container">\[\begin{aligned}
\int_{\overline{M}_{0,1}(\mathbb{P}^{2},2)}\mathrm{ev}_{1}^{*}\mathcal{O}_{\mathbb{P}^{2}}(1)^{2}\cdot\psi_{1}^{4} &amp;= \frac{1}{8} \\
\int_{\overline{M}_{0,2}(\mathbb{P}^{2},1)}\psi_{1}^{2}\psi_{2}^{2} &amp;= 6 \\
\int_{\overline{M}_{0,1}(\mathbb{P}^{3},2)}\mathrm{ev}_{1}^{*}\mathcal{O}_{\mathbb{P}^{2}}(1)\cdot(\psi_{1}^{7}\cdot\mathrm{ev}_{1}^{*}\mathcal{O}_{\mathbb{P}^{2}}(1)+\psi_{1}^{6}\cdot\mathrm{ev}_{1}^{*}\mathcal{O}_{\mathbb{P}^{2}}(1)^{2}) &amp;= -\frac{5}{16} \\
\end{aligned}\]</p><p>can be computed as</p><pre><code class="language-julia-repl hljs">julia&gt; v = projective_space(NormalToricVariety, 2);  # 2-dimensional projective space

julia&gt; line = cohomology_class(toric_divisor(v, [1,0,0])); # the cohomology class of a line

julia&gt; P = ev(1, line)^2*Psi(4);

julia&gt; IntegrateAB(v, 2*line, 1, P, show_bar=false);
Result: 1//8

julia&gt; Q = Psi(2,2);

julia&gt; IntegrateAB(v, line, 2, Q, show_bar=false);
Result: 6

julia&gt; v = projective_space(NormalToricVariety, 3);  # 3-dimensional projective space

julia&gt; plane = cohomology_class(toric_line_bundle(v, [1])); # cohomology class of a plane

julia&gt; P = ev(1, plane)*(Psi(7)*ev(1, plane)+Psi(6)*ev(1, plane)^2);

julia&gt; IntegrateAB(v, 2*plane^2, 1, P, show_bar=false);
Result: -5//16</code></pre><div class="admonition is-warning"><header class="admonition-header">Psi is singleton!</header><div class="admonition-body"><p><code>Psi</code> cannot be multiplied by itself.</p><pre><code class="language-julia-repl hljs">julia&gt; v = projective_space(NormalToricVariety, 2);  # 2-dimensional projective space
julia&gt; line = cohomology_class(toric_divisor(v, [1,0,0])); # the cohomology class of a line
julia&gt; P = ev(1, line)^2*Psi(1)^4;                  #this is **wrong**
julia&gt; IntegrateAB(v, 2*line, 1, P);
Warning: more instances of Psi has been found. Type:
julia&gt; ?Psi
for support.
julia&gt; P = ev(1, line)^2*Psi(3)*Psi(1);            #this is **wrong**
julia&gt; IntegrateAB(v, 2*line, 1, P);
Warning: more instances of Psi has been found. Type:
julia&gt; ?Psi
for support.
julia&gt; P = ev(1, line)^2*Psi(4);
julia&gt; IntegrateAB(v, 2*line, 1, P);
Result: 1//8</code></pre></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mgemath/ToricAtiyahBott.jl/blob/9a00c7a10e8c198e10e7843ffe261af037c9c8c1/src/Psi_class.jl#L4-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ToricAtiyahBott.push_ev" href="#ToricAtiyahBott.push_ev"><code>ToricAtiyahBott.push_ev</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">push_ev(l)</code></pre><p>Equivariant class of the push-forward under the forget map of the pull-back of the  toric line bundle <span>$l$</span>.</p><p><strong>Arguments</strong></p><ul><li><code>l::ToricLineBundle</code>: the line bundle.</li></ul><p><strong>Example</strong></p><p>The following Gromov-Witten invariants</p><p class="math-container">\[\begin{aligned}
\int_{\overline{M}_{0,0}(\mathbb{P}^{4},1)}\mathrm{c_{top}}(\delta_{*}(\mathrm{ev}^{*}\mathcal{O}_{\mathbb{P}^{4}}(5))) &amp;= 2875 \\
\int_{\overline{M}_{0,1}(\mathbb{P}^{4},1)}\mathrm{c_{top}}(\delta_{*}(\mathrm{ev}^{*}\mathcal{O}_{\mathbb{P}^{4}}(5)))\cdot\psi_{1}^{1} &amp;= -5750
\end{aligned}\]</p><p>can be computed as</p><pre><code class="language-julia-repl hljs">julia&gt; v = projective_space(NormalToricVariety, 4);

julia&gt; line = cohomology_class(toric_line_bundle(v, [1]))^3;

julia&gt; P = push_ev(toric_line_bundle(v, [5]));

julia&gt; IntegrateAB(v, line, 0, P, show_bar=false);
Result: 2875

julia&gt; P = push_ev(toric_line_bundle(v, [5]))*Psi(1);

julia&gt; IntegrateAB(v, line, 1, P, show_bar=false);
Result: -5750</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mgemath/ToricAtiyahBott.jl/blob/9a00c7a10e8c198e10e7843ffe261af037c9c8c1/src/push_ev_class.jl#L5-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ToricAtiyahBott.R1_ev" href="#ToricAtiyahBott.R1_ev"><code>ToricAtiyahBott.R1_ev</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">R1_ev(l)</code></pre><p>The equivariant class of the first derived functor of the pull-back of the toric line bundle <span>$l$</span>.</p><p><strong>Arguments</strong></p><ul><li><code>l::ToricLineBundle</code>: the line bundle.</li></ul><p><strong>Example</strong></p><p class="math-container">\[\begin{aligned}
\int_{\overline{M}_{0,0}(\mathbb{P}^{1},d)}\mathrm{c_{top}}(R^{1}\delta_{*}(\mathrm{ev}^{*}\mathcal{O}_{\mathbb{P}^{3}}(-1)))^2 &amp;= \frac{1}{d^3} \
\end{aligned}\]</p><p>can be computed as</p><pre><code class="language-julia-repl hljs">julia&gt; P1 = projective_space(NormalToricVariety, 1);

julia&gt; beta = moment_graph(P1)[1,2];
(1,2) -&gt; 1

julia&gt; P = R1_ev(toric_line_bundle(P1, [-1]))^2;

julia&gt; IntegrateAB(P1, beta, 0, P, show_bar=false);
Result: 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mgemath/ToricAtiyahBott.jl/blob/9a00c7a10e8c198e10e7843ffe261af037c9c8c1/src/R1_ev_class.jl#L5-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ToricAtiyahBott.Jet" href="#ToricAtiyahBott.Jet"><code>ToricAtiyahBott.Jet</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Jet(p, l)</code></pre><p>Equivariant class of the jet bundle <span>$J^p$</span> of the pull back of the toric line bundle <span>$l$</span> with respect to the first <span>$\psi$</span>-class.</p><p><strong>Arguments</strong></p><ul><li><code>p::Int64</code>: the exponent of the Jet bundle. In particular, it is a bundle of rank <span>$p+1$</span>.</li><li><code>l::Int64</code>: the toric line bundle that is pulled back.</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>In order to define this bundle, the number of marks must be at least 1. You cannot multiply this bundle by the class <code>Psi(a)</code>.</p></div></div><p><strong>Example</strong></p><p class="math-container">\[\begin{aligned}
\int_{\overline{M}_{0,1}(\mathbb{P}^{3},d)}\frac{\mathrm{ev}_{1}^{*}\mathcal{O}_{\mathbb{P}^{3}}(1)^{2}}{k}\cdot\mathrm{c_{top}}(J^{4d-2}(\mathrm{ev}_{1}^{*}\mathcal{O}_{\mathbb{P}^{3}}(k))) &amp;= \frac{(4d-2)!}{(d!)^{4}} \\
\int_{\overline{M}_{0,1}(\mathbb{P}^{2},1)}\mathrm{c_{top}}(J^{2}(\mathrm{ev}_{1}^{*}\mathcal{O}_{\mathbb{P}^{2}}(3))) &amp;= 9 \\
\end{aligned}\]</p><p>can be computed as</p><pre><code class="language-julia-repl hljs">julia&gt; d=1;k=1; #for other values of d, change this line

julia&gt; v = projective_space(NormalToricVariety, 3);

julia&gt; line = cohomology_class(toric_divisor(v, [1,0,0,0]))^2;

julia&gt; beta = d*line;

julia&gt; l = toric_line_bundle(v, [k]);

julia&gt; P = ev(1,line)//k*Jet(4*d-2,l);

julia&gt; IntegrateAB(v, beta, 1, P, show_bar=false);   #The value of this integral does not depend on k, only on d
Result: 2

julia&gt; v = projective_space(NormalToricVariety, 2);

julia&gt; l = toric_line_bundle(v, [1]);

julia&gt; line = cohomology_class(l);

julia&gt; IntegrateAB(v, line, 1, Jet(2, l^3), show_bar=false); # flexes of a cubic curve
Result: 9</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mgemath/ToricAtiyahBott.jl/blob/9a00c7a10e8c198e10e7843ffe261af037c9c8c1/src/Jet_class.jl#L5-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ToricAtiyahBott.push_omega" href="#ToricAtiyahBott.push_omega"><code>ToricAtiyahBott.push_omega</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">push_omega(l)</code></pre><p>Equivariant class of the push-forward under the forgetful map of <span>$ev^*l$</span> tensored the cotangent bundle of the forgetful map.</p><p><strong>Arguments</strong></p><ul><li><code>l::ToricLineBundle</code>: the line bundle.</li></ul><p><strong>Example</strong></p><p>The following Gromov-Witten invariants</p><p class="math-container">\[\begin{aligned}
\int_{\overline{M}_{0,2}(\mathbb{P}^{3},1)}\mathrm{ev}_{1}^{*}\mathcal{O}_{\mathbb{P}^{3}}(1)^{2}\cdot\mathrm{ev}_{2}^{*}\mathcal{O}_{\mathbb{P}^{3}}(1)^{3}\cdot\mathrm{c_{top}}(\delta_{*}(\omega_{\delta}\otimes\mathrm{ev}^{*}\mathcal{O}_{\mathbb{P}^{3}}(2))) &amp;= 1 \\
\end{aligned}\]</p><p>can be computed as</p><pre><code class="language-julia-repl hljs">julia&gt; v = projective_space(NormalToricVariety, 3);

julia&gt; line = cohomology_class(toric_line_bundle(v, [1]))^2;

julia&gt; P = push_omega(toric_line_bundle(v, [2]))*ev(1, line)*ev(2, a_point(v));

julia&gt; IntegrateAB(v, line, 2, P, show_bar=false);
Result: 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mgemath/ToricAtiyahBott.jl/blob/9a00c7a10e8c198e10e7843ffe261af037c9c8c1/src/push_omega_class.jl#L5-L30">source</a></section></article><h2 id="Other-Functions"><a class="docs-heading-anchor" href="#Other-Functions">Other Functions</a><a id="Other-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Other-Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ToricAtiyahBott.vir_dim_M" href="#ToricAtiyahBott.vir_dim_M"><code>ToricAtiyahBott.vir_dim_M</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">vir_dim_M(v, beta, m)</code></pre><p>The virtual dimension of the moduli space of stable rational map to the toric variety <code>v</code>, of class <code>beta</code> with <code>m</code> marks.</p><p><strong>Arguments</strong></p><ul><li><code>v::NormalToricVariety</code>: the toric variety.</li><li><code>beta::CohomologyClass</code>: the class of the stable maps.</li><li><code>m::Int64</code>: the number of marks.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; v = projective_space(NormalToricVariety, 2);

julia&gt; beta = cohomology_class(toric_divisor(v, [1,0,0]));

julia&gt; vir_dim_M(v,beta,0)
2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mgemath/ToricAtiyahBott.jl/blob/9a00c7a10e8c198e10e7843ffe261af037c9c8c1/src/Checks.jl#L8-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ToricAtiyahBott.codimension" href="#ToricAtiyahBott.codimension"><code>ToricAtiyahBott.codimension</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">codimension(v, beta, m, P)</code></pre><p>The codimension of the equivariant class <code>P</code>.</p><p><strong>Arguments</strong></p><ul><li><code>v::NormalToricVariety</code>: the toric variety.</li><li><code>beta::CohomologyClass</code>: the class of the stable maps.</li><li><code>m::Int64</code>: the number of marks. If omitted, it is assumed as <code>m=0</code>.</li><li><code>P</code>: the equivariant class.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mgemath/ToricAtiyahBott.jl/blob/9a00c7a10e8c198e10e7843ffe261af037c9c8c1/src/Checks.jl#L33-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ToricAtiyahBott.is_zero_cycle" href="#ToricAtiyahBott.is_zero_cycle"><code>ToricAtiyahBott.is_zero_cycle</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_zero_cycle(v, beta, m, P)</code></pre><p>Return <code>true</code> if the equivariant class <code>P</code> is a 0-cycle in the moduli space, <code>false</code> otherwise.</p><p><strong>Arguments</strong></p><ul><li><code>v::NormalToricVariety</code>: the toric variety.</li><li><code>beta::CohomologyClass</code>: the class of the stable maps.</li><li><code>m::Int64</code>: the number of marks.</li><li><code>P</code>: the equivariant class.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mgemath/ToricAtiyahBott.jl/blob/9a00c7a10e8c198e10e7843ffe261af037c9c8c1/src/Checks.jl#L48-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ToricAtiyahBott.a_point" href="#ToricAtiyahBott.a_point"><code>ToricAtiyahBott.a_point</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">a_point(v)</code></pre><p>The cohomology of a point of <code>v</code>.</p><p><strong>Arguments</strong></p><ul><li><code>v::NormalToricVariety</code>: the toric variety.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mgemath/ToricAtiyahBott.jl/blob/9a00c7a10e8c198e10e7843ffe261af037c9c8c1/src/Misc.jl#L5-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ToricAtiyahBott.moment_graph" href="#ToricAtiyahBott.moment_graph"><code>ToricAtiyahBott.moment_graph</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">moment_graph(v; show_graph)</code></pre><p>The moment graph of the toric variety <span>$v$</span>. It prints all pairs <span>$(i,j)$</span>, together with the cohomology class of the invariant curve passing through the points corresponding to the maximal cones <span>$i$</span> and <span>$j$</span>. The cohomology class is expressed in the coordinates of the Chow ring. </p><p><strong>Arguments</strong></p><ul><li><code>v::NormalToricVariety</code>: the toric variety.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; P2 = projective_space(NormalToricVariety, 2);

julia&gt; mg = moment_graph(P2);
(1,2) -&gt; x3
(1,3) -&gt; x3
(2,3) -&gt; x3

julia&gt; C = mg[1,2];</code></pre><p>If <code>show_graph</code> is omitted or false, the output is omitted.</p><pre><code class="language-julia-repl hljs">julia&gt; P1 = projective_space(NormalToricVariety, 1);

julia&gt; mg = moment_graph(P1, show_graph=false);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mgemath/ToricAtiyahBott.jl/blob/9a00c7a10e8c198e10e7843ffe261af037c9c8c1/src/MaxCones.jl#L56-L80">source</a></section></article><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#ToricAtiyahBott"><code>ToricAtiyahBott</code></a></li><li><a href="#ToricAtiyahBott.IntegrateAB"><code>ToricAtiyahBott.IntegrateAB</code></a></li><li><a href="#ToricAtiyahBott.Jet"><code>ToricAtiyahBott.Jet</code></a></li><li><a href="#ToricAtiyahBott.Psi"><code>ToricAtiyahBott.Psi</code></a></li><li><a href="#ToricAtiyahBott.R1_ev"><code>ToricAtiyahBott.R1_ev</code></a></li><li><a href="#ToricAtiyahBott.a_point"><code>ToricAtiyahBott.a_point</code></a></li><li><a href="#ToricAtiyahBott.codimension"><code>ToricAtiyahBott.codimension</code></a></li><li><a href="#ToricAtiyahBott.ev"><code>ToricAtiyahBott.ev</code></a></li><li><a href="#ToricAtiyahBott.is_zero_cycle"><code>ToricAtiyahBott.is_zero_cycle</code></a></li><li><a href="#ToricAtiyahBott.moment_graph"><code>ToricAtiyahBott.moment_graph</code></a></li><li><a href="#ToricAtiyahBott.push_ev"><code>ToricAtiyahBott.push_ev</code></a></li><li><a href="#ToricAtiyahBott.push_omega"><code>ToricAtiyahBott.push_omega</code></a></li><li><a href="#ToricAtiyahBott.vir_dim_M"><code>ToricAtiyahBott.vir_dim_M</code></a></li></ul></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Thursday 7 September 2023 13:12">Thursday 7 September 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
